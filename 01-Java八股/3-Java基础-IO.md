# Java基础-IO



## 1.什么是用户态与内核态？

**1. 内核态：“全能管理者”**

内核态是操作系统内核运行时的状态，具备 **最高权限**：

- 能直接访问计算机的核心资源，比如 **进程调度（决定哪个程序运行）、内存读写、硬件设备（网卡、硬盘）、文件系统** 等。
- 相当于系统的 “管理员”，可以无限制操作底层硬件和系统数据。

**2. 用户态：“受限执行者”**

用户态是普通应用程序（比如浏览器、微信）运行时的状态，权限 **非常有限**：

- 只能访问自己的 “用户空间”（比如程序的内存、文件），无法直接触碰内核管理的核心资源（如直接操作硬盘、修改系统进程）。
- 相当于系统的 “普通用户”，必须通过 **系统接口（系统调用）** 向内核 “申请权限”，才能完成敏感操作（比如读写硬盘文件、申请大内存）。

**3. 状态切换：“权限申请的代价”**

当用户态程序需要内核态的资源时（比如打开文件），会触发 **系统调用**，从用户态切换到内核态：

- **切换开销大**：切换时需要保存用户态的运行状态（比如程序计数器、寄存器值），加载内核态的环境，还要做权限检查，这会消耗 CPU 时间。
- 因此，系统设计上会尽量 **减少内核态切换次数**（比如批量处理系统调用），避免频繁开销拖慢性能。



## 2.BIO（Blocking I/O 阻塞IO）

**当应用程序发起 I/O 操作（如读、写数据）时，发起操作的线程会被 “阻塞”，直到 I/O 操作完全完成后，线程才会继续执行后续任务**。

简单说，BIO 的核心就是 “等”——I/O 没完成，线程就一直等，啥也干不了。

**具体过程可以这样理解：**

比如一个程序要从网络中读取数据（如服务器接收客户端消息）：

1. 程序调用`read()`等 I/O 函数，发起 “读取数据” 的请求；
2. 如果此时数据还未准备好（比如网络数据还在传输中，尚未到达服务器），发起请求的线程会进入 “阻塞状态”—— 暂停执行，不做任何事，只等待数据准备；
3. 当数据准备完成后，操作系统会将数据从内核空间复制到用户空间（应用程序可访问的内存区域）；
4. 复制完成后，I/O 操作结束，阻塞的线程被 “唤醒”，继续执行后续代码。

<img src="https://raw.githubusercontent.com/Yzitong/When-Java-meets-LLM/main/images/image-20250818144052649.png" alt="image-20250818144052649" style="zoom:50%;" />

**特点与局限：**

- **优点**：实现简单，逻辑直观，适合连接数少、I/O 操作频繁且耗时短的场景（如简单的本地文件读写）。
- **缺点**：阻塞会导致线程资源浪费。比如在高并发网络通信中，若为每个客户端连接分配一个线程，当线程因等待 I/O 而阻塞时，这些线程无法处理其他任务，会导致系统线程数量暴增，耗尽 CPU 和内存资源。

## 3.NIO（Non-blocking IO 非阻塞IO）

**当应用程序发起 I/O 操作时，即使数据未准备好，发起操作的线程也不会被阻塞，而是可以立即返回并继续执行其他任务**。

简单说，NIO 的核心是 “不傻等”——I/O 没准备好就先干别的，准备好了再回来处理，用更少的线程干更多的事。

**具体工作过程（以网络数据读取为例）：**

1. 程序调用非阻塞的 I/O 函数（如`read()`）发起 “读取数据” 请求；
2. 如果此时数据未准备好（如网络数据尚未到达），I/O 函数会立即返回一个 “数据未就绪” 的标识（而非阻塞等待），线程可以继续处理其他任务（如处理已就绪的连接、执行计算等）；
3. 线程可以通过**轮询**（主动检查）或**事件通知**的方式，定期查看数据是否准备好；
4. 当数据准备完成后，操作系统将数据从内核空间复制到用户空间，此时 I/O 操作完成，线程再处理数据。

<img src="https://raw.githubusercontent.com/Yzitong/When-Java-meets-LLM/main/images/image-20250818152533698.png" alt="image-20250818152533698" style="zoom: 67%;" />

**对比 BIO 的优势与局限：**

- **优势**：
  1. 非阻塞特性减少了线程闲置：线程无需等待 I/O，可高效处理其他任务；
  2. 多路复用支持高并发：通过 Selector，一个线程可管理成百上千个连接，大幅降低线程资源消耗（避免 BIO 中 “一个连接一个线程” 的浪费）。
- **局限**：
  1. 轮询机制可能消耗 CPU：如果频繁检查数据是否就绪（尤其是无数据时），会空耗 CPU 资源；
  2. 实现复杂度高：需要处理事件监听、缓冲区管理等逻辑，比 BIO 更复杂。

**典型场景：**

NIO 适合高并发、I/O 操作频繁但单次操作耗时短的场景，如：

- 高并发服务器（如聊天服务器、即时通讯系统）；
- 需要同时处理大量网络连接的场景（如分布式系统中的节点通信）。



## 4.IO多路复用

IO 多路复用的核心原理是**用单个线程同时监控多个 Socket**，当某个 Socket 的 I/O 事件（如 “可读”“可写”）就绪时，再通知程序处理，从而避免线程因无效等待（如 Socket 数据未准备好）而浪费 CPU 资源。其原理可结合图中三种实现（select、poll、epoll）的差异进一步理解：

![image-20250818152352390](https://raw.githubusercontent.com/Yzitong/When-Java-meets-LLM/main/images/image-20250818152352390.png)

简言之，IO 多路复用通过 “单个线程监控多 Socket + 事件通知”，解决了传统 BIO “一个连接一个线程” 的资源浪费问题；而 epoll 通过 “直接返回就绪 Socket”，进一步优化了 select/poll 的遍历开销，成为高并发场景的主流选择。

<img src="https://raw.githubusercontent.com/Yzitong/When-Java-meets-LLM/main/images/image-20250818153217791.png" alt="image-20250818153217791" style="zoom:67%;" />