# 2. Transformer灵魂20问

指路：[transformer模型— 20道面试题自我检测_transformer面试题-CSDN博客](https://blog.csdn.net/m0_51879931/article/details/134142492)

博客里写的不全，我在其基础上做了补充。

## Q1：Transformer 为何使用多头注意力机制？（为什么不使用一个头）

Transformer 模型中使用多头注意力机制主要是为了提高模型捕捉信息的能力。下面是使用多头注意力机制的一些优点：

- **捕捉多种依赖关系**：不同的注意力头可以学习到序列中不同位置之间的不同依赖关系。一个头可能专注于捕捉语法依赖，另一个头可能专注于语义依赖，这样模型就能够更全面地理解输入数据。
- **提高模型容量**：多头注意力机制增加了模型的容量，使得模型能够学习到更复杂的表示。
- **更好的泛化能力**：由于多头注意力机制能够从多个角度分析输入数据，模型的泛化能力得到提升。
- **并行计算**：多头注意力机制的计算可以并行进行，这提高了训练和推理的效率。

如果只使用一个头，模型的表达能力和学习能力会受到限制，可能无法充分捕捉到输入数据中的复杂依赖关系，从而影响模型的性能。多头注意力机制通过组合多个注意力头的输出，能够提供更丰富、更强大的表示。

------

## Q2：Transformer 为什么 Q 和 K 使用不同的权重矩阵生成，为何不能使用同一个值进行自身的点乘？（注意和第一个问题的区别）

在 Transformer 模型中，查询（Query）、键（Key）和值（Value）是自注意力机制的三个核心组成部分。每个单词会被映射为这三种表示。Q 和 K 使用不同的权重矩阵生成的原因主要是为了提供更灵活的模型表示能力和捕捉数据中的复杂依赖关系。

- **灵活性**：如果 Q 和 K 使用相同的权重矩阵或者相同的值进行自身的点乘，那么它们之间的关系会被严格限制在一个固定的模式中，这限制了模型的灵活性。使用不同的权重矩阵为 Q 和 K 提供了能力去捕捉不同的依赖关系，增强了模型对输入数据的理解。
- **表示能力**：不同的权重矩阵意味着 Q 和 K 可以在不同的语义空间中进行表达，这有助于模型捕捉更丰富的语义信息和依赖关系。
- **区分不同角色**：在自注意力机制中，Q、K 和 V 扮演着不同的角色。Q 代表了我们要查询的信息，K 代表了我们用来与 Q 匹配的键，而 V 代表了一旦找到匹配，我们要提取的值。使用不同的权重矩阵能够更好地区分这些不同的角色，提高模型的效果。

总的来说，虽然在某些情况下使用相同的值进行自身的点乘（或者共享权重矩阵）可能也能工作得很好，但使用不同的权重矩阵为 Q 和 K 提供了更大的灵活性和表示能力，有助于提升模型性能和泛化能力。

------

## Q3：Transformer 计算 attention 的时候为何选择点乘而不是加法？两者计算复杂度和效果上有什么区别？

在 Transformer 模型中，计算注意力时使用点乘而不是加法，是基于效率和建模能力的考虑。

**点乘注意力**：
$$ \text{Attention}(Q, K, V) = \text{softmax}\left(\frac{QK^T}{\sqrt{d_k}}\right)V $$
其中，Q、K、V分别是查询（Query）、键（Key）和值（Value）矩阵，$d_k$是键的维度。 

优点： 

- 效率：点乘操作可以通过矩阵乘法高效地在硬件上并行化，从而实现快速计算。 
- 建模能力：点乘注意力能够捕捉查询和键之间的相似度，当查询和键相似时给予更高的权重，这有助于模型捕捉输入序列中的复杂依赖关系。 

缺点：

- 当维度较高时，点乘的结果可能会非常大，导致softmax函数的输出非常接近0或1，这会造成梯度消失的问题。这也是为什么点乘注意力中会除以$\sqrt{d_k}$的原因，它有助于缓解这个问题。 

**加法注意力：**

$$\text{Attention}(Q, K, V) = \text{softmax}\left(\text{score}(Q, K)\right)V$$ 

在上述公式中，$\text{Attention}(Q, K, V)$表示注意力函数，它使用查询（Q）、键（K）和值（V）作为输入，并输出加权求和的值（V）。$\text{score}(Q, K)$函数计算查询和键之间的相似度，其结果会经过一个softmax函数进行归一化，以确定每个值的权重大小。 

优点：

-  对于较长的序列，加法注意力的性能可能会优于点乘注意力。 

缺点： 

- 计算复杂度较高，因为需要为每一对查询和键计算分数。 

**计算复杂度对比：** 

点乘注意力的计算复杂度为$O(n^2 \cdot d)$，其中n是序列长度，d是维度。 加法注意力的计算复杂度为$O(n^2 \cdot d)$，但常数因子可能更大，因为需要为每一对查询和键计算复杂的分数函数。 

**效果对比：**

 在大多数任务中，点乘注意力和加法注意力的性能差异不大。 点乘注意力在硬件上更容易并行化，通常计算更快。 在某些长序列任务中，加法注意力可能会略优于点乘注意力。 

综上所述，点乘注意力在Transformer模型中被选择主要是因为其效率和强大的建模能力。虽然在计算上可能会有梯度消失的问题，但通过合适的缩放（如除以$\sqrt{d_k}$）可以缓解这个问题。加法注意力虽然在某些方面有其优势，但在大多数应用中，点乘注意力的性能和效率更胜一筹。

------

## Q4：为什么在进行 softmax 之前需要对 attention 进行 scaled（为什么除以 ( d_k ) 的平方根），并使用公式推导进行讲解

在 Transformer 模型中，Scaled Dot-Product Attention 是这样计算的：
$$ \text{Attention}(Q, K, V) = \text{softmax}\left(\frac{QK^T}{\sqrt{d_k}}\right)V $$
这里 Q, K, V 分别代表查询（Query）、键（Key）和值（Value），( d_k ) 是键的维度。

**为什么需要进行 scaled**？

- **防止点乘结果过大**：Q 和 K 都是高维向量，当它们进行点乘时，结果可能会非常大，尤其是当维度 ( d_k ) 较高时。点乘结果过大会导致 softmax 函数的输入值非常大，而 softmax 函数是一个指数函数，这会导致其输出的梯度非常小。这种情况下，在进行反向传播时，梯度几乎都是 0，这会导致梯度消失问题，使得模型难以学习。
- **保持梯度稳定**：除以 ( \sqrt{d_k} ) 可以保证无论 ( d_k ) 取什么值，点乘的结果都处在一个合理的范围内，这有助于保持梯度的稳定性，加速模型的训练过程。

**公式推导和解释**：
考虑两个向量 x 和 y，它们的点乘可以表示为：
$$ x \cdot y = \sum_{i=1}^{d_k} x_i y_i $$
当 x 和 y 的维度 ( d_k ) 很大时，上面的求和可能会导致非常大的数值。为了避免这种情况，我们将点乘的结果除以 ( \sqrt{d_k} )，将其放缩到一个合理的范围内。
$$ \text{scaled}(x \cdot y) = \frac{x \cdot y}{\sqrt{d_k}} = \frac{\sum_{i=1}^{d_k} x_i y_i}{\sqrt{d_k}} $$
这样，无论 ( d_k ) 取多大的值，点乘的结果都处于一个较为稳定的范围内，有助于防止梯度消失问题，使得模型能够更快地收敛。

------

## Q5：在计算 attention score 的时候如何对 padding 做 mask 操作？

在计算注意力分数时，我们通常不希望模型将注意力放在填充（padding）的词上，因为这些词是人为添加的，没有实际意义。为了实现这一点，我们可以在计算注意力分数之后、应用 softmax 函数之前进行掩码操作（masking）。

**具体步骤**：

1. **创建掩码矩阵**：对于输入序列中的每个位置，如果该位置是填充词，则在掩码矩阵的对应位置放置一个非常大的负数（如 -1e9），否则放置 0。
2. **应用掩码矩阵**：将掩码矩阵加到注意力分数上。因为掩码矩阵中填充词的位置是非常大的负数，加上它们之后，这些位置的注意力分数也会变成非常大的负数。
3. **应用 softmax 函数**：在加了掩码的注意力分数上应用 softmax 函数。由于填充词位置的分数是非常大的负数，经过 softmax 函数后，这些位置的权重将接近于 0，而其他位置的权重将保持不变（因为 softmax 是一个归一化函数）。
4. **计算加权和**：使用 softmax 的输出作为权重，计算值（Value）的加权和。

通过这种方法，模型在计算注意力时会忽略填充词，从而聚焦在实际有意义的词上。这有助于提高模型的性能，因为它不会浪费计算资源在无关紧要的填充词上。

------

## Q6：为什么在进行多头注意力的时候需要对每个 head 进行降维？为什么要设计多头注意力而不用单头注意力？（可以参考上面一个问题）

在进行多头注意力计算时，我们将输入分配到不同的头上，每个头独立地进行注意力计算。对于每个头的计算，我们都需要对查询（Query）、键（Key）和值（Value）进行线性变换，即通过权重矩阵将它们从原始维度映射到较低的维度。这个过程中的降维有几个好处：

- **参数共享**：通过将输入映射到较低维度的子空间，我们可以在每个头上应用相同的注意力机制，但是每个头学习到的是不同的线性#xaiArtifact不同的线性变换，从而实现参数共享并减少模型的总参数量。
- **增加模型容量**：多头注意力机制允许模型在不同的表示子空间上并行地学习。即使每个头工作在较低维度的子空间中，组合多个头的结果可以捕捉到不同子空间中的信息，从而增加模型的容量。
- **提高计算效率**：由于每个头工作在较低维度的空间中，注意力计算的复杂度降低，从而提高了计算效率。注意力计算的复杂度与维度的平方成正比，所以降维可以显著减少计算量。
- **增强模型的泛化能力**：由于每个头学习到的是不同的注意力模式，即使某些头북被噪声或者不相关的信息干扰，其他头仍然可以提供有用的信息，从而增强了模型的泛化能力。

综上所述，进行多头注意力计算时对每个头进行降维，可以在减少计算复杂度、提高效率的同时，增强模型的学习能力和泛化能力。这使得多头注意力机制成为一种非常强大和灵活的模型组件。

------

## Q7：大概讲一下 Transformer 的 Encoder 模块？

Transformer 的 Encoder 模块是由一系列相同的层堆叠而成的，每一层都有两个主要的子模块：多头自注意力机制（Multi-Head Self-Attention）和前馈神经网络（Position-wise Feed-Forward Networks）。此外，每个子模块周围都有一个残差连接，并且每个子模块的输出都会经过层归一化（Layer Normalization）。下面是对这些组件的详细说明：

1. **多头自注意力机制（Multi-Head Self-Attention）**：这个模块可以使网络在进行预测时考虑输入序列的不同位置，对不同位置的输入分配不同的注意力。多头注意力机制意味着模型有多组不同的注意力参数，每组都会输出一个注意力权重，这些注意力权重会被合并成最终的注意力输出。
2. **残差连接（Residual Connection）**：残差连接帮助避免了深度神经网络中的梯度消失问题。在 Transformer 中，每个子模块的输出是 LayerNorm(x + SubLayer(x))，其中 SubLayer(x) 是子模块自身（比如多头自注意力或前馈神经网络）的输出。
3. **层归一化（Layer Normalization）**：层归一化是在模型的训练过程中加速收敛的一种技术，它对层的输入进行归一化处理，使得其均值为 0，方差为 1。
4. **前馈神经网络（Position-wise Feed-Forward Networks）**：这个模块由两个线性变换组成，中间夹有一个 ReLU 激活函数。它对每个位置的词向量独立地进行变换。
5. **位置编码（Position Encoding）**：由于 Transformer 模型没有循环或卷积操作，为了让模型能够利用词的顺序信息，需要在输入嵌入层中加入位置编码。位置编码和词嵌入相加后输入到 Encoder 模块。

整体来看，Transformer 的 Encoder 模块将输入序列转换为一系列连续表示，这些表示在后续的 Decoder 模块中用于生成输出序列。每一层的 Encoder 都对输入序列的所有位置同时进行操作，而不是像 RNN 那样逐个位置处理，这是 Transformer 模型高效并行处理的关键。

------

## Q8：为何在获取输入词向量之后需要对矩阵乘以 embedding size 的开方？意义是什么？

将词嵌入矩阵乘以嵌入维度（embedding dimension）的平方根是为了对模型进行缩放，目的是防止在计算自注意力（self-attention）时得到的数值过大。在自注意力机制中，我们计算输入序列中每个元素对其他所有元素的注意力分数，这涉及到一个点积操作，可能导致非常大的数值，特别是当嵌入维度较大时。

将嵌入乘以嵌入维度的平方根可以帮助缓解这个问题，使得点积的范围更加合理，从而帮助模型的训练稳定性。这个缩放操作有助于避免在训练过程中出现梯度消失或梯度爆炸的问题，使得模型更容易训练，最终达到更好的性能。

简而言之，这个操作的目的是为了数值稳定性和训练稳定性，帮助模型更有效地学习从输入到输出的映射。

------

## Q9：简单介绍一下 Transformer 的位置编码？有什么意义和优缺点？

Transformer 模型采用自注意力机制处理序列数据，与传统的循环神经网络（RNN）和长短时记忆网络（LSTM）不同，它不依赖于序列的递归处理，因此无法直接捕捉到序列中的位置信息。为了解决这个问题，Transformer 引入了位置编码（Positional Encoding）的概念，将位置信息添加到模型的输入中。

**位置编码的定义和计算**：
位置编码是一个与词嵌入维度相同的向量，它被加到词嵌入上，以提供关于单词在序列中位置的信息。位置编码的公式如下：
对于位置 pos 和维度 i，位置编码的第 i 个元素被定义为：
$$ PE(pos, 2i) = \sin\left(\frac{pos}{10000^{\frac{2i}{d}}}\right) $$
$$ PE(pos, 2i+1) = \cos\left(\frac{pos}{10000^{\frac{2i}{d}}}\right) $$
其中，d 是词嵌入的维度，pos 是词在序列中的位置，i 是维度的索引。

**优缺点**：

- 优点：
  - **固定模式**：位置编码是根据绝对位置计算的，而且是固定的，这意味着模型在训练和测试时使用相同的位置编码，保持一致性。
  - **可推广性**：由于位置编码是基于三角函数计算的，它能够处理比训练时见过的序列更长的输入。
  - **并行计算**：与 RNN 和 LSTM 不同，Transformer 模型能够利用位置编码一次性处理整个序列，这使得模型能够充分利用现代硬件的并行计算能力，显著提高训练和推断的速度。
- 缺点：
  - **固定长度**：尽管位置编码能够处理长序列，但是它们是根据固定长度计算的，这意味着如果序列太长，位置编码可能会失效。
  - **可能需要更多的训练数据**：由于位置信息是通过位置编码隐式提供的，模型需要从数据中学习如何最好地利用这些信息，这可能需要更多的训练数据。

总的来说，位置编码是 Transformer 模型的一个关键部分，它使模型能够处理序列数据，捕捉到元素之间的顺序关系。尽管存在一些限制，但它的引入是实现高效并行处理的重要步骤。

------

## Q10：你还了解哪些关于位置编码的技术，各自的优缺点是什么？

位置编码是解决 Transformer 模型中无法直接捕获序列位置信息的关键技术。除了 Transformer 原始论文中提出的正弦和余弦函数形式的位置编码外，还有一些其他的位置编码技术。

- **学习的位置编码**：
  - **优点**：模型可以学习到最适合特定任务的位置编码，可能在某些任务上表现更好。
  - **缺点**：需要更多的参数和训练数据；不能很好地泛化到训练时未见过的更长序列。
- **相对位置编码**：
  - 这种方法不是将位置编码直接加到词嵌入上，而是在计算注意力分数时考虑元素之间的相对位置。
  - **优点**：能够更好地处理序列的局部结构，因为它关注的是元素之间的相对位置。
  - **缺点**：计算更复杂，可能增加训练和推理的时间。
- **固定但可学习的位置编码**：
  - 这种方法结合了固定的位置编码和学习的位置编码的优点。
  - **优点**：能够在保持一定泛化能力的同时，适应特定任务的需求。
  - **缺点**：仍然需要更多的参数。
- **轴向位置编码**：
  - 这种方法通过将位置编码分解为多个维度上的函数来降低参数数量。
  - **优点**：参数更少，更高效。
  - **缺点**：可能损失一些表达能力。
- **Transformer-XL 中的位置编码**：
  - Transformer-XL 引入了一种新的位置编码方法，用于处理超长序列。
  - **优点**：能够更好地处理长序列，并捕捉长范围的依赖关系。
  - **缺点**：结构更复杂，计算成本更高。

每种位置编码方法都有其自身的优点和缺点，适用于不同的任务和需求。选择哪种位置编码技术取决于具体的应用场景和性能需求。

------

## Q11：简单讲一下 Transformer 中的残差结构以及意义

在 Transformer 模型中，残差连接（或残差网络）是一种关键结构，它有助于训练深层网络。残差连接的基本思想是允许网络中的信息和梯度直接跨过一个或多个层进行传播。

**残差结构的工作方式**：
在 Transformer 中的每个子层（如自注意力层和前馈神经网络层）后面，都会有一个残差连接，然后是一个层归一化（Layer Normalization）操作。具体来说，如果我们将子层的操作表示为 F(x)，那么残差连接的输出就是 x + F(x)。这里的 x 是子层的输入，x + F(x) 是残差连接的输出，也是下一层的输入。

**残差结构的意义**：

- **缓解梯度消失**：残差连接允许梯度直接流过网络，这有助于缓解深层网络中常见的梯度消失问题，从而使得模型更容易训练。
- **提升训练速度**：残差连接提供了一种直接的信息传播路径，可以加速训练过程。
- **增强网络能力**：通过允许信息直接传递，残差连接使网络能够学习到更复杂的表示，增强了模型的能力。
- **增加网络深度**：残差结构使得训练非常深的网络成为可能，而不用担心梯度消失或者训练难度的问题。
- **保持前向信息的完整性**：由于残差连接的加法操作，即使某个子层没有学到有用的信息（或者学到了错误的信息），输入信息 x 也仍然能够通过残差连接传到下一层，这有助于保持前向传播过程中信息的完整性。

总的来说，Transformer 中的残差结构对于模型的训练稳定性和性能至关重要，它们使得深层和复杂的网络结构能够高效地训练，从而在各种自然语言处理任务中取得优异的表现。

------

## Q12：为什么 Transformer 块使用 LayerNorm 而不是 BatchNorm？LayerNorm 在 Transformer 的位置是哪里？

（原文未详细展开，仅提及“从视频 25:07 开始看，讲解的很清晰”，故保留问题框架）

------

## Q13：简答讲一下 BatchNorm 技术，以及它的优缺点

（原文未详细展开，仅提及“同上”，故保留问题框架）

------

## Q14：简单描述一下 Transformer 中的前馈神经网络？使用了什么激活函数？相关优缺点？

Transformer 中的前馈神经网络（Feed-Forward Neural Network, FFN）是模型每个注意力头后的一个重要组成部分。这个前馈神经网络对每个位置的词向量进行相同的操作，但它并不在不同位置间共享参数。

**结构描述**：
每个前馈神经网络包含两个线性变换，中间夹一个激活函数。具体来说，如果 x 是输入，则计算过程为：
$$ FFN(x) = \max(0, xW_1 + b_1)W_2 + b_2 $$
其中，( W_1 ), ( W_2 ), ( b_1 ), ( b_2 ) 是网络参数，x 是输入的词向量，通常维度为 ( d_{\text{model}} )。第一个线性层将输入从 ( d_{\text{model}} ) 维扩展到 ( d_{\text{ff}} ) 维，然后应用激活函数，再通过第二个线性层将维度从 ( d_{\text{ff}} ) 缩减回 ( d_{\text{model}} )。

**激活函数**：
在原始的 Transformer 模型中，激活函数使用的是 ReLU（Rectified Linear Unit）：
$$ \text{ReLU}(x) = \max(0, x) $$

**优缺点**：

- 优点：
  - **非线性**：前馈神经网络引入了非线性变换，增加了模型的表达能力，使得 Transformer 能够学习到更复杂的函数映射。
  - **并行计算**：由于前馈神经网络对每个位置的操作是独立的，所以可以高效地进行并行计算，提高训练和推理的速度。
  - **简单高效**：前馈神经网络结构简单，计算效率高，易于优化。
- 缺点：
  - **局限性**：前馈神经网络在处理序列数据时只能考虑单个位置的信息，无法捕捉序列中的上下文关系。这种局限性通过 Transformer 中的自注意力机制来解决。
  - **参数量大**：尽管结构简单，但前馈神经网络中参数量较大，特别是当 ( d_{\text{ff}} ) 很大时，这可能导致过拟合和增加模型的计算负担。

总的来说，前馈神经网络是 Transformer 模型的重要组成部分，提供了非线性处理能力，虽然它有一些局限性，但与自注意力机制结合后，能够在处理复杂序列任务方面表现出卓越性能。

------

## Q15：Encoder 端和 Decoder 端是如何进行交互的？（在这里可以问一下关于 seq2seq 的 attention 知识）

Encoder 和 Decoder 之间的交互主要通过交叉注意力机制实现。具体来说：

- **查询来自 Decoder**：在交叉注意力层中，查询（Query）来自于 Decoder 的上一层的输出。
- **键和值来自 Encoder**：键（Key）和值（Value）来自于 Encoder 的输出。

通过计算查询与键的相似度，模型可以为每个 Encoder 输出分配一个权重，然后将这些权重应用于值，以产生一个加权和，该加权和将用作交叉注意力层的输出，并输入到下一层。

这种机制使 Decoder 能够关注输入序列的不同部分，特别是在生成每个新单词时。例如，在机器翻译任务中，当模型生成目标语言的一个单词时，它可以通过这种机制来聚焦于源语言句子中的相关部分。

**总结**：
在 Transformer 模型中，Encoder 和 Decoder 通过交叉注意力机制进行交互。这种机制使模型能够在生成输出序列的每一步都考虑到输入序列的全部信息，从而捕捉输入和输出之间的复杂依赖关系，并在各种 seq2seq 任务中实现卓越的性能。

------

## Q16：Decoder 阶段的多头自注意力和 Encoder 的多头自注意力有什么区别？（为什么需要 Decoder 自注意力进行 sequence mask）

Decoder 阶段的多头自注意力（Masked Multi-Head Attention）和 Encoder 的多头自注意力（Multi-Head Attention）在计算方式上非常相似，但存在关键的区别，主要体现在对序列中位置的处理上。

**Encoder 的多头自注意力**：
在 Encoder 的多头自注意力中，每个位置都可以自由地注意序列中的所有其他位置。这意味着计算注意力分数时，并没有位置上的限制。这种设置是因为在编码阶段，我们假定有完整的输入序列，并且每个词都可以依赖于上下文中的任何其他词来获得其表示。

**Decoder 的多头自注意力（带掩码）**：
在 Decoder 的多头自注意力中，为了保持自回归属性（即生成当前词只依赖于前面的词），我们需要确保在计算注意力分数时，每个位置只能注意到它前面的位置。为了实现这一点，我们使用了序列掩码（sequence mask）的技术。

具体来说，序列掩码是在注意力分数计算之前，将当前位置之后所有位置的分数设置为一个非常大的负数（通常是负无穷）。这样，在接下来的 softmax 操作中，这些位置的注意力权重将变为 0，确保模型不会注意到这些位置。

**为什么需要 Decoder 自注意力进行序列掩码**？
在序列生成任务中，如机器翻译或文本生成，模型需要一次生成一个词，并且生成当前词时只能依赖于前面已经生成的词。如果我们不使用序列掩码，模型就能够“看到”后续的词，这与实际生成过程不符，并且会导致信息泄露，使模型学习到错误的依赖关系。

总的来说，Encoder 的多头自注意力允许每个位置自由地注意到整个序列，而 Decoder 的多头自注意力则通过序列掩码来限制注意范围，以保持自回归属性，确保生成过程的正确性。这种设计是 Transformer 模型能够有效处理序列生成任务的关键所在。

------

## Q17：Transformer 的并行化体现在哪个地方？Decoder 端可以做并行化吗？

Transformer 模型由于其独特的结构特性，在训练阶段具有很强的并行化能力。以下是一些主要的并行化方面：

1. **自注意力机制的并行化**：在自注意力层中，模型计算输入序列中所有位置的单词之间的注意力分数，并且这些计算是相互独立的。因此，它们可以在不同的处理单元上并行执行。同样，一旦计算出注意力分数，对输入单词的线性变换也可以并行进行。
2. **前馈神经网络的并行化**：前馈神经网络对输入序列的每个位置执行相同的操作，并且这些操作是独立的。因此，它们也可以在不同的处理单元上并行执行。
3. **多头注意力的并行化**：Transformer 模型使用多头注意力机制，其中不同的注意力头可以在不同的处理单元上并行计算。
4. **层与层之间的并行化**：由于 Transformer 模型的层与层之间没有递归连接，不同层之间的计算也可以并行进行。

**Decoder 端的并行化**：
虽然 Transformer 的 Decoder 端在训练时可以进行并行计算（因为整个目标序列是已知的），但在推理（生成）阶段，Decoder 的并行化变得复杂。这是因为生成一个词需要依赖于前面已经生成的词。因此，序列生成通常是串行过程，每次生成一个词，然后将其添加到序列中以用于生成下一个词。

然而，有一些方法和模型变种试图解决这个问题，使得在推理阶段也能实现并行化。例如，模型可以被训练来一次生成一个词，但这通常需要对模型架构和训练过程进行显著的修改。

总的来说，Transformer 的并行化主要体现在训练阶段，特别是在其自注意力和前馈神经网络层中。尽管 Decoder 端在推理阶段的并行化存在挑战，但通过一些先进的技术和模型变种，这个问题是可以缓解的。

------

## Q18：（原文未提及第 18 题内容，故空缺）

------

## Q19：Transformer 训练时学习率是如何设定的？Dropout 是如何设定的，位置在哪里？Dropout 在测试时有什么需要注意的？

Transformer 模型在训练时对学习率和 Dropout 的设置非常关键，这直接影响到模型的收敛速度和最终性能。

**学习率**：
Transformer 模型通常使用一种特殊的学习率调度策略，称为“Noam”学习率预热策略。具体来说，学习率随着训练的进行先增大后减小，计算公式为：
 $$\text{lr} = d_{\text{model}}^{-0.5} \cdot \min\left(\text{step\_num}^{-0.5}, \text{step\_num} \cdot \text{warmup\_steps}^{-1.5}\right)$$ 

其中，$d_{\text{model}}$是模型的隐藏层大小，$\text{step\_num}$是当前的训练步数，$\text{warmup\_steps}$是预热的步数。

这种学习率调度策略有助于模型在训练初期快速收敛，同时在训练后期通过减小学习率来稳定训练。

**Dropout**：
Dropout 是一种正则化技术，用于防止神经网络过拟合。在 Transformer 模型中，Dropout 被应用在以下几个地方：

- 在注意力权重计算后，用于随机“丢弃”一些权重，以防止模型过分依赖某些特定的输入。
- 在每个子层（自注意力层，前馈神经网络层等）的输出后，用于防止过拟合。
- 在词嵌入层和位置编码的加和后。

Dropout 率（即随机丢弃的神经元比例）是一个超参数，需要根据具体任务进行调整。常见的取值范围在 0.1 到 0.3 之间。

**Dropout 在测试时的注意事项**：
在测试（或推理）阶段，通常会禁用 Dropout，确保所有的神经元都参与到计算中，以获得最稳定的模型输出。这是因为 Dropout 在训练时引入了随机性，而在测试时我们希望模型的表现是确定的。在许多深度学习框架中，可以通过设置模型为评估模式来自动禁用 Dropout。

总的来说，学习率和 Dropout 在 Transformer 模型训练中起着关键的作用，合理的设置有助于模型更快地收敛并提高最终性能。而在测试阶段，通常会禁用 Dropout 以确保模型输出的稳定性。

------

## Q20：解码端的残差结构有没有把后续未被看见的 mask 信息添加进来，造成信息的泄露

在 Transformer 模型的解码端，为了避免在生成当前词时看到后续的词（这在实际应用中是不可行的，比如机器翻译时，模型不能提前知道将要生成的词），会使用一个被称为“查看屏蔽”的技术。这种屏蔽确保在计算自注意力时，一个词只能注意到它前面的词，而不能注意到后面的词。

具体来说，这是通过在计算自注意力分数之前，将屏蔽矩阵添加到分数上实现的。屏蔽矩阵的作用是将要屏蔽掉的位置（即当前词之后的所有位置）设置为一个非常大的负数（通常是负无穷）。当这些分数通过 softmax 函数时，它们将变为 0，确保模型不会注意到这些位置。

残差连接本身并不涉及屏蔽或注意力计算。残差连接是将某层的输入直接添加到该层的输出，以帮助梯度在深层网络中更有效地流动。在解码器的自注意力层之后，残差连接确实会添加到应用屏蔽之后的输出上，但这不会引入任何额外的信息，因为屏蔽已经确保了模型不能“看到”后续的词。

因此，残差结构本身不会导致信息泄露或“看到”后续的词。相反，它是一种帮助模型更有效地训练的技术，而屏蔽机制则确保解码过程中的信息流是正确和安全的。