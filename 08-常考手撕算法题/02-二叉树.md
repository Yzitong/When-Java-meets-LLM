# 二叉树

## **二叉树的前序、中序、后序遍历（模版）**

三种遍历都有递归写法和迭代写法，递归写法较简单，迭代写法考查更多，需重点掌握。

**前序：*根*左右** 

**中序：左*根*右** 

**后序：左右*根***

递归写法：

```java
class Solution {
    public List<Integer> inorderTraversal(TreeNode root) {
        List<Integer> res = new ArrayList<Integer>();
        inorder(root, res);
        return res;
    }

    public void inorder(TreeNode root, List<Integer> res) {
        if (root == null) {
            return;
        }
        //前序遍历
        //res.add(root.val);
        inorder(root.left, res);
        res.add(root.val);//中序遍历
        inorder(root.right, res);
        //后序遍历
        //res.add(root.val);
    }
}
```

迭代算法中，其他模版完全相同，唯一区别在何时将当前节点加入输出的数组中！在条件语句中：左右上 **——** **前中后！**

<img src="https://raw.githubusercontent.com/Yzitong/When-Java-meets-LLM/main/images/image-20250819191113804.png" alt="image-20250819191113804" style="zoom:67%;" />

```java
class Solution {
    public List<Integer> preorderTraversal(TreeNode root) {
        // 前序遍历的结果
        List<Integer> preorderReslut = new ArrayList<>();
        // 中序遍历的结果
        List<Integer> inorderResult = new ArrayList<>();
        // 后序遍历的结果
        List<Integer> postorderResult = new ArrayList<>();
        // 设置一个栈，用来保存路径
        Stack<TreeNode> stack = new Stack<>();
        // 设置一个节点，一开始指向根节点
        TreeNode node = root;
        // 设置三种状态
        // 左代表该节点的左右孩子节点都没有遍历
        int nodeLeft = 100;
        // 右代表该节点的左孩子节点已经遍历，右孩子节点还没有遍历
        int nodeRight = 200;
        // 上代表左右孩子节点都已经遍历，需要返回到它的父节点
        int nodeUp = 300;
        // 每个节点的初始化状态都是从 左 开始
        int nodeState = nodeLeft;

        // 对二叉树进行遍历
        while(node != null){
            // 如果当前节点的状态是【左】，说明该节点的左右孩子节点都没有遍历
            if(nodeState == nodeLeft){
                // 把当前节点加入到二叉树前序遍历的结果数组中
                preorderReslut.add(node.val);
                // 如果当前节点有左子树
                if(node.left != null){
                    // 先把当前节点加入到栈中，用来记录节点移动的路径
                    stack.push(node);
                    // 开始观察当前节点的左孩子节点
                    node = node.left;
                }else{
                    // 如果当前节点没有左子树，切换当前节点的状态为【右】
                    nodeState = nodeRight;
                }
            // 如果当前节点的状态是【右】，说明该节点的左孩子节点已经遍历，右孩子节点还没有遍历       
            }else if(nodeState == nodeRight){ 
                // 把当前节点加入到二叉树中序遍历的结果数组中
                // inorderResult.add(node.val);
                // 如果当前节点有右子树
                if(node.right != null){
                    // 先把当前节点加入到栈中，用来记录节点移动的路径
                    stack.push(node);
                    // 开始观察当前节点的右孩子节点
                    node = node.right;
                    // 每个节点开始的状态都是【左】开始，所以需要重新设置一下节点的状态
                    nodeState = nodeLeft;
     
                }else{
                    // 如果当前节点没有右子树，切换当前节点的状态为【上】
                    nodeState = nodeUp;
                }
            // 如果当前节点的状态是【上】，说明左右孩子节点都已经遍历，需要返回到它的父节点
            }else if(nodeState == nodeUp){ 
                // 把当前节点加入到二叉树后序遍历的结果数组中
                //postorderResult.add(node.val);
                // 需要返回到当前节点的父节点位置，通过栈顶元素来获取当前节点的父节点
                TreeNode parent = null;
                // 如果栈中有元素
                if(!stack.isEmpty()){
                    // 那么，栈顶元素就是当前节点的父节点
                    parent = stack.pop();
                    // 判断一下父节点的左节点是否为当前节点
                    // 比如这颗二叉树
                    //           1
                    //         /   \
                    //        2     3
                    //       / \     \
                    //      4   5     6
                    //  如果当前节点是 4 ，那么 4 的父节点是 2，2 的左孩子节点是 4，此时需要切换状态为【右】
                    //  如果当前节点是 5 ，那么 2的左右已经遍历结束，此时不需要切换状态，仍为UP
                    // 如果父节点的左节点为当前节点
                    if(parent.left == node){
                        // 切换当前节点的状态为【右】
                        nodeState = nodeRight;
                    }
                }
                
                // 如果上述代码中栈中有元素，那么当前节点的父节点作为新的观察节点
                // 如果上述代码中栈中没有元素，那么 parent 没有值，会跳出循环
                node = parent;
            }
        }
        // 根据题目要求，返回二叉树前序、中序、后序遍历的结果
        return preorderReslut;
    }
}
```

简洁版：二叉树的中序遍历

```java
class Solution {
    public List<Integer> inorderTraversal(TreeNode root) {
        //思路：二叉树遍历有模版，模版需理解背诵，其中左右上-前中后
        List<Integer> inorderResult = new ArrayList<Integer>();
        Stack<TreeNode> stack = new Stack<TreeNode>();

        int nodeLeft = 1;
        int nodeRight = 2;
        int nodeUp = 3;
        int nodeState = nodeLeft;

        TreeNode node = root;
        while(node != null){
            if(nodeState == nodeLeft){
                if (node.left != null){
                    stack.push(node);
                    node = node.left;
                }else{
                    nodeState = nodeRight;
                }

            }else if(nodeState == nodeRight){
                inorderResult.add(node.val);
                if (node.right != null){
                    stack.push(node);
                    node = node.right;
                    nodeState = nodeLeft;
                }else{
                    nodeState = nodeUp;
                }

            }else if(nodeState == nodeUp){
                TreeNode parent = null;
                if (!stack.isEmpty()){
                    parent = stack.pop();
                    if (node == parent.left){
                        nodeState = nodeRight;
                    }
                }
                
                node = parent;
            }

        }
        return inorderResult;
    }
}
```



## 二叉树的最大深度

给定一个二叉树 `root` ，返回其最大深度。

二叉树的 **最大深度** 是指从根节点到最远叶子节点的最长路径上的节点数。

```java
class Solution {
    public int maxDepth(TreeNode root) {
        //思路：求左右孩子的最大深度，取最大值，再加一

         // 细节：边界情况处理
        if (root == null) return 0;
        
        int left = maxDepth(root.left);
        int right = maxDepth(root.right);
        int childheight = Math.max(left,right);
        return childheight+1;
    }
}
```

## 翻转二叉树

给你一棵二叉树的根节点 `root` ，翻转这棵二叉树，并返回其根节点。

```java
class Solution {
    public TreeNode invertTree(TreeNode root) {
        //思路：利用递归

        // 1、递归终止条件一，当前节点为空的时候，就返回 null
        if(root == null) return null;

        // 2、递归终止条件二，当前节点为叶子节点的时候，就返回这个节点
        if( root.left == null && root.right == null){
            
            // 返回这个节点
            return root;

        }
        TreeNode left = invertTree(root.left);
        TreeNode right = invertTree(root.right);
        root.left = right;
        root.right = left;
        return root;
    }
}
```

## 对称二叉树

给你一个二叉树的根节点 `root` ， 检查它是否轴对称。

```java
class Solution {
    public boolean isSymmetric(TreeNode root) {
        //利用递归的思路
        if (root == null) return true;
        else return recur(root.left,root.right);
    }
    //判断左右子树是否对称的条件
    boolean recur(TreeNode L,TreeNode R){
        //先判断左右的根节点是否对称，对称再进行递归判断
        if(L == null && R == null){
            return true;
        }else if(L == null || R == null || L.val != R.val){
            return false;
        }else{
            return recur(L.left,R.right) && recur(L.right,R.left);
        }

    }
}
```

## 二叉树的直径

给你一棵二叉树的根节点，返回该树的 **直径** 。

二叉树的 **直径** 是指树中任意两个节点之间最长路径的 **长度** 。这条路径可能经过也可能不经过根节点 `root` 。

两节点之间路径的 **长度** 由它们之间边数表示。

```java
class Solution {
    int max;
    public int diameterOfBinaryTree(TreeNode root) {
        //思路，观察发现直径=左孩子深度+右孩子深度，在这个过程中的最大值
        //难点：意识到直径的产生不一定经过根节点，是一个过程最大值，设定一个局部变量去记录。
        max = 0;
        depthMax(root);
        return max;
        
    }
    //求二叉树的最大深度（经过的节点数）
    public int depthMax(TreeNode root){
        if (root == null) return 0;
        int left = depthMax(root.left);
        int right = depthMax(root.right);
        //记录过程最大值
        //边数 = 节点数 - 1，直径是经过的最大边数和
        if(left-1 + right-1 +2 > max){
            max = left + right; 
        }
        return Math.max(left,right) + 1;
    }
}
```

## 二叉树的层序遍历

给你二叉树的根节点 `root` ，返回其节点值的 **层序遍历** 。 （即逐层地，从左到右访问所有节点）。

![image-20250820094112546](https://raw.githubusercontent.com/Yzitong/When-Java-meets-LLM/main/images/image-20250820094112546.png)

```java
class Solution {
    public List<List<Integer>> levelOrder(TreeNode root) {
        //思路：二叉树的BFS广度优先遍历，利用队列的数据结构
        //注：DFS用递归，例：求深度。BFS用队列
        Queue<TreeNode> queue = new ArrayDeque<TreeNode>();//背
        //先把根节点放进去
        if (root != null) {
            queue.add(root);
        }

        List<List<Integer>> res = new ArrayList<List<Integer>>();

        while(!queue.isEmpty()){
            int n = queue.size();
            List<Integer> list = new ArrayList<Integer>();
            for(int i = 0;i < n;i++){
                TreeNode node = queue.poll();
                list.add(node.val);
                //将此层根节点的全部左右节点放入，作为新的根节点
                if (node.left != null){
                    queue.add(node.left);
                }
                if(node.right != null){
                    queue.add(node.right);
                }
            }
            res.add(list);
        }

        return res;
        
    }
}
```

## 将有序数组转换为二叉搜索树

给你一个整数数组 `nums` ，其中元素已经按 **升序** 排列，请你将其转换为一棵 平衡 二叉搜索树。

```java
class Solution {
    public TreeNode sortedArrayToBST(int[] nums) {
        //平衡二叉搜索树：平衡：任一节点的左右子树高度差距相同或只相差 1
        //二叉搜索树：需要满足中序遍历是升序的

        //思路：每一次选择中间位置为根节点
        return helper(nums,0,nums.length - 1);


        
    }
    public TreeNode helper(int[] nums,int left,int right){
        if(left > right) return null;
        int mid = (left + right)/2;
        TreeNode root = new TreeNode(nums[mid]);
        root.left = helper(nums,left,mid - 1);
        root.right = helper(nums,mid + 1,right);
        return root;
    }
}
```

## 验证二叉搜索树

给你一个二叉树的根节点 `root` ，判断其是否是一个有效的二叉搜索树。

**有效** 二叉搜索树定义如下：

- 节点的左子树只包含 **严格小于** 当前节点的数。
- 节点的右子树只包含 **严格大于** 当前节点的数。
- 所有左子树和右子树自身必须也是二叉搜索树。

```java
class Solution {
    public boolean isValidBST(TreeNode root) {
        //思路：还是递归思想，一般这种直接return的都需要一个helper。
        //关键是将长度作为传参进行比较,作为结束条件
        //细节：当值在整数区间内时，我们可以用long类型来避免错误
        //对于左子树，取值范围为：（-∞，root.val]；对于右子树，取值范围为： [root.val,+∞)
        return helper(root, Long.MIN_VALUE, Long.MAX_VALUE);
    }

    //lower 和 upper 分别代表当前节点值的下界（左边界） 和上界（右边界）
    public boolean helper(TreeNode node, long lower, long upper) {
        if (node == null) {
            return true;
        }
        if (node.val <= lower || node.val >= upper) {
            return false;
        }
        return helper(node.left, lower, node.val) && helper(node.right, node.val, upper);
    }
}
```

