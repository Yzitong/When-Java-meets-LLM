# 二叉树

## **二叉树的前序、中序、后序遍历（模版）**

三种遍历都有递归写法和迭代写法，递归写法较简单，迭代写法考查更多，需重点掌握。

**前序：*根*左右** 

**中序：左*根*右** 

**后序：左右*根***

递归写法：

```java
class Solution {
    public List<Integer> inorderTraversal(TreeNode root) {
        List<Integer> res = new ArrayList<Integer>();
        inorder(root, res);
        return res;
    }

    public void inorder(TreeNode root, List<Integer> res) {
        if (root == null) {
            return;
        }
        //前序遍历
        //res.add(root.val);
        inorder(root.left, res);
        res.add(root.val);//中序遍历
        inorder(root.right, res);
        //后序遍历
        //res.add(root.val);
    }
}
```

迭代算法中，其他模版完全相同，唯一区别在何时将当前节点加入输出的数组中！在条件语句中：左右上 **——** **前中后！**

<img src="https://raw.githubusercontent.com/Yzitong/When-Java-meets-LLM/main/images/image-20250819191113804.png" alt="image-20250819191113804" style="zoom:67%;" />

```java
class Solution {
    public List<Integer> preorderTraversal(TreeNode root) {
        // 前序遍历的结果
        List<Integer> preorderReslut = new ArrayList<>();
        // 中序遍历的结果
        List<Integer> inorderResult = new ArrayList<>();
        // 后序遍历的结果
        List<Integer> postorderResult = new ArrayList<>();
        // 设置一个栈，用来保存路径
        Stack<TreeNode> stack = new Stack<>();
        // 设置一个节点，一开始指向根节点
        TreeNode node = root;
        // 设置三种状态
        // 左代表该节点的左右孩子节点都没有遍历
        int nodeLeft = 100;
        // 右代表该节点的左孩子节点已经遍历，右孩子节点还没有遍历
        int nodeRight = 200;
        // 上代表左右孩子节点都已经遍历，需要返回到它的父节点
        int nodeUp = 300;
        // 每个节点的初始化状态都是从 左 开始
        int nodeState = nodeLeft;

        // 对二叉树进行遍历
        while(node != null){
            // 如果当前节点的状态是【左】，说明该节点的左右孩子节点都没有遍历
            if(nodeState == nodeLeft){
                // 把当前节点加入到二叉树前序遍历的结果数组中
                preorderReslut.add(node.val);
                // 如果当前节点有左子树
                if(node.left != null){
                    // 先把当前节点加入到栈中，用来记录节点移动的路径
                    stack.push(node);
                    // 开始观察当前节点的左孩子节点
                    node = node.left;
                }else{
                    // 如果当前节点没有左子树，切换当前节点的状态为【右】
                    nodeState = nodeRight;
                }
            // 如果当前节点的状态是【右】，说明该节点的左孩子节点已经遍历，右孩子节点还没有遍历       
            }else if(nodeState == nodeRight){ 
                // 把当前节点加入到二叉树中序遍历的结果数组中
                // inorderResult.add(node.val);
                // 如果当前节点有右子树
                if(node.right != null){
                    // 先把当前节点加入到栈中，用来记录节点移动的路径
                    stack.push(node);
                    // 开始观察当前节点的右孩子节点
                    node = node.right;
                    // 每个节点开始的状态都是【左】开始，所以需要重新设置一下节点的状态
                    nodeState = nodeLeft;
     
                }else{
                    // 如果当前节点没有右子树，切换当前节点的状态为【上】
                    nodeState = nodeUp;
                }
            // 如果当前节点的状态是【上】，说明左右孩子节点都已经遍历，需要返回到它的父节点
            }else if(nodeState == nodeUp){ 
                // 把当前节点加入到二叉树后序遍历的结果数组中
                //postorderResult.add(node.val);
                // 需要返回到当前节点的父节点位置，通过栈顶元素来获取当前节点的父节点
                TreeNode parent = null;
                // 如果栈中有元素
                if(!stack.isEmpty()){
                    // 那么，栈顶元素就是当前节点的父节点
                    parent = stack.pop();
                    // 判断一下父节点的左节点是否为当前节点
                    // 比如这颗二叉树
                    //           1
                    //         /   \
                    //        2     3
                    //       / \     \
                    //      4   5     6
                    //  如果当前节点是 4 ，那么 4 的父节点是 2，2 的左孩子节点是 4，此时需要切换状态为【右】
                    //  如果当前节点是 5 ，那么 2的左右已经遍历结束，此时不需要切换状态，仍为UP
                    // 如果父节点的左节点为当前节点
                    if(parent.left == node){
                        // 切换当前节点的状态为【右】
                        nodeState = nodeRight;
                    }
                }
                
                // 如果上述代码中栈中有元素，那么当前节点的父节点作为新的观察节点
                // 如果上述代码中栈中没有元素，那么 parent 没有值，会跳出循环
                node = parent;
            }
        }
        // 根据题目要求，返回二叉树前序、中序、后序遍历的结果
        return preorderReslut;
    }
}
```

简洁版：二叉树的中序遍历

```java
class Solution {
    public List<Integer> inorderTraversal(TreeNode root) {
        //思路：二叉树遍历有模版，模版需理解背诵，其中左右上-前中后
        List<Integer> inorderResult = new ArrayList<Integer>();
        Stack<TreeNode> stack = new Stack<TreeNode>();

        int nodeLeft = 1;
        int nodeRight = 2;
        int nodeUp = 3;
        int nodeState = nodeLeft;

        TreeNode node = root;
        while(node != null){
            if(nodeState == nodeLeft){
                if (node.left != null){
                    stack.push(node);
                    node = node.left;
                }else{
                    nodeState = nodeRight;
                }

            }else if(nodeState == nodeRight){
                inorderResult.add(node.val);
                if (node.right != null){
                    stack.push(node);
                    node = node.right;
                    nodeState = nodeLeft;
                }else{
                    nodeState = nodeUp;
                }

            }else if(nodeState == nodeUp){
                TreeNode parent = null;
                if (!stack.isEmpty()){
                    parent = stack.pop();
                    if (node == parent.left){
                        nodeState = nodeRight;
                    }
                }
                
                node = parent;
            }

        }
        return inorderResult;
    }
}
```



## 二叉树的最大深度

给定一个二叉树 `root` ，返回其最大深度。

二叉树的 **最大深度** 是指从根节点到最远叶子节点的最长路径上的节点数。

```java
class Solution {
    public int maxDepth(TreeNode root) {
        //思路：求左右孩子的最大深度，取最大值，再加一

         // 细节：边界情况处理
        if (root == null) return 0;
        
        int left = maxDepth(root.left);
        int right = maxDepth(root.right);
        int childheight = Math.max(left,right);
        return childheight+1;
    }
}
```

## 翻转二叉树

给你一棵二叉树的根节点 `root` ，翻转这棵二叉树，并返回其根节点。

```java
class Solution {
    public TreeNode invertTree(TreeNode root) {
        //思路：利用递归

        // 1、递归终止条件一，当前节点为空的时候，就返回 null
        if(root == null) return null;

        // 2、递归终止条件二，当前节点为叶子节点的时候，就返回这个节点
        if( root.left == null && root.right == null){
            
            // 返回这个节点
            return root;

        }
        TreeNode left = invertTree(root.left);
        TreeNode right = invertTree(root.right);
        root.left = right;
        root.right = left;
        return root;
    }
}
```

## 对称二叉树

给你一个二叉树的根节点 `root` ， 检查它是否轴对称。

```java
class Solution {
    public boolean isSymmetric(TreeNode root) {
        //利用递归的思路
        if (root == null) return true;
        else return recur(root.left,root.right);
    }
    //判断左右子树是否对称的条件
    boolean recur(TreeNode L,TreeNode R){
        //先判断左右的根节点是否对称，对称再进行递归判断
        if(L == null && R == null){
            return true;
        }else if(L == null || R == null || L.val != R.val){
            return false;
        }else{
            return recur(L.left,R.right) && recur(L.right,R.left);
        }

    }
}
```

## 二叉树的直径

给你一棵二叉树的根节点，返回该树的 **直径** 。

二叉树的 **直径** 是指树中任意两个节点之间最长路径的 **长度** 。这条路径可能经过也可能不经过根节点 `root` 。

两节点之间路径的 **长度** 由它们之间边数表示。

```java
class Solution {
    int max;
    public int diameterOfBinaryTree(TreeNode root) {
        //思路，观察发现直径=左孩子深度+右孩子深度，在这个过程中的最大值
        //难点：意识到直径的产生不一定经过根节点，是一个过程最大值，设定一个局部变量去记录。
        max = 0;
        depthMax(root);
        return max;
        
    }
    //求二叉树的最大深度（经过的节点数）
    public int depthMax(TreeNode root){
        if (root == null) return 0;
        int left = depthMax(root.left);
        int right = depthMax(root.right);
        //记录过程最大值
        //边数 = 节点数 - 1，直径是经过的最大边数和
        if(left-1 + right-1 +2 > max){
            max = left + right; 
        }
        return Math.max(left,right) + 1;
    }
}
```

## 二叉树的层序遍历

给你二叉树的根节点 `root` ，返回其节点值的 **层序遍历** 。 （即逐层地，从左到右访问所有节点）。

![image-20250820094112546](https://raw.githubusercontent.com/Yzitong/When-Java-meets-LLM/main/images/image-20250820094112546.png)

```java
class Solution {
    public List<List<Integer>> levelOrder(TreeNode root) {
        //思路：二叉树的BFS广度优先遍历，利用队列的数据结构
        //注：DFS用递归，例：求深度。BFS用队列
        Queue<TreeNode> queue = new ArrayDeque<TreeNode>();//背
        //先把根节点放进去
        if (root != null) {
            queue.add(root);
        }

        List<List<Integer>> res = new ArrayList<List<Integer>>();

        while(!queue.isEmpty()){
            int n = queue.size();
            List<Integer> list = new ArrayList<Integer>();
            for(int i = 0;i < n;i++){
                TreeNode node = queue.poll();
                list.add(node.val);
                //将此层根节点的全部左右节点放入，作为新的根节点
                if (node.left != null){
                    queue.add(node.left);
                }
                if(node.right != null){
                    queue.add(node.right);
                }
            }
            res.add(list);
        }

        return res;
        
    }
}
```

## 将有序数组转换为二叉搜索树

给你一个整数数组 `nums` ，其中元素已经按 **升序** 排列，请你将其转换为一棵 平衡 二叉搜索树。

```java
class Solution {
    public TreeNode sortedArrayToBST(int[] nums) {
        //平衡二叉搜索树：平衡：任一节点的左右子树高度差距相同或只相差 1
        //二叉搜索树：需要满足中序遍历是升序的

        //思路：每一次选择中间位置为根节点
        return helper(nums,0,nums.length - 1);


        
    }
    public TreeNode helper(int[] nums,int left,int right){
        if(left > right) return null;
        int mid = (left + right)/2;
        TreeNode root = new TreeNode(nums[mid]);
        root.left = helper(nums,left,mid - 1);
        root.right = helper(nums,mid + 1,right);
        return root;
    }
}
```

## 验证二叉搜索树

给你一个二叉树的根节点 `root` ，判断其是否是一个有效的二叉搜索树。

**有效** 二叉搜索树定义如下：

- 节点的左子树只包含 **严格小于** 当前节点的数。
- 节点的右子树只包含 **严格大于** 当前节点的数。
- 所有左子树和右子树自身必须也是二叉搜索树。

```java
class Solution {
    public boolean isValidBST(TreeNode root) {
        //思路：还是递归思想，一般这种直接return的都需要一个helper。
        //关键是将长度作为传参进行比较,作为结束条件
        //细节：当值在整数区间内时，我们可以用long类型来避免错误
        //对于左子树，取值范围为：（-∞，root.val]；对于右子树，取值范围为： [root.val,+∞)
        return helper(root, Long.MIN_VALUE, Long.MAX_VALUE);
    }

    //lower 和 upper 分别代表当前节点值的下界（左边界） 和上界（右边界）
    public boolean helper(TreeNode node, long lower, long upper) {
        if (node == null) {
            return true;
        }
        if (node.val <= lower || node.val >= upper) {
            return false;
        }
        return helper(node.left, lower, node.val) && helper(node.right, node.val, upper);
    }
}
```

## 二叉搜索树中第K小的元素

给定一个二叉搜索树的根节点 `root` ，和一个整数 `k` ，请你设计一个算法查找其中第 `k` 小的元素（从 1 开始计数）。

```java
class Solution {
    public int kthSmallest(TreeNode root, int k) {
        //思路：二叉搜索树中序遍历按照升序排列，找到第k个元素
        //也就是说，本题可被转化为求中序遍历的第 k 个节点。

        List<Integer> inorder = new ArrayList<Integer>(); 
        TreeNode node  = root;
        int nodeleft = 1;
        int noderight = 2;
        int nodeup = 3;
        Stack<TreeNode> stack = new Stack<TreeNode>();
        int nodestate = nodeleft;


        while(node != null){
            if (nodestate == nodeleft){
                if(node.left != null){
                    stack.push(node);
                    node = node.left;
                }else{
                    nodestate = noderight;
                }

            }else if(nodestate == noderight){
                inorder.add(node.val);
                // System.out.println(node.val);
                k--;
                if(node.right != null){
                    stack.push(node);
                    node = node.right;
                    nodestate = nodeleft;
                }else{
                    nodestate = nodeup;
                }

            }else{
                TreeNode parent = null;
                if(!stack.isEmpty()){
                    parent = stack.pop();
                    if(parent.left == node){
                        nodestate = noderight;
                    }
                }
                
                node = parent;

            }
            if(k == 0){
                break;
            }
        }
        int size = inorder.size();

        return inorder.get(size - 1);
        
    }
}
```

## 二叉树的右视图

给定一个二叉树的 **根节点** `root`，想象自己站在它的右侧，按照从顶部到底部的顺序，返回从右侧所能看到的节点值。

```java
class Solution {
    public List<Integer> rightSideView(TreeNode root) {
        //思路：层序遍历，取每层的最后一个值

        Queue<TreeNode> queue = new ArrayDeque<TreeNode>();
        List<Integer> res = new ArrayList<Integer>();

        if (root != null) queue.add(root);
        while(!queue.isEmpty()){
            int n = queue.size();
            List<Integer> list = new ArrayList<Integer>();
            for(int i = 0;i < n;i++){
                TreeNode node = queue.poll();
                list.add(node.val);
                if(node.left != null){
                        queue.add(node.left);
                }
                if(node.right != null){
                        queue.add(node.right);
                }
            }
            res.add(list.get(n - 1));
        }
        return res;
    }
}
```

## 二叉树展开为链表

给你二叉树的根结点 `root` ，请你将它展开为一个单链表：

- 展开后的单链表应该同样使用 `TreeNode` ，其中 `right` 子指针指向链表中下一个结点，而左子指针始终为 `null` 。
- 展开后的单链表应该与二叉树 [**先序遍历**](https://baike.baidu.com/item/先序遍历/6442839?fr=aladdin) 顺序相同。

```java
class Solution {
    public void flatten(TreeNode root) {
        //思路：下面两步重复完成这道题
        //1、将左子树插入到右子树的地方
        //2.将原来的右子树接到左子树的最右边节点
        //注意，当node的左子树为null时，即只有右子树时，不能进行上述操作直接下一个。
        TreeNode node = root;
        while(node != null){
            //左子树为 null，直接考虑下一个节点
            if (node.left == null) {
                node = node.right;
            } else {
                //1、将左子树插入到右子树的地方
                TreeNode ori_r = node.right;
                node.right = node.left;
                node.left = null;
                //2.将原来的右子树接到左子树的最右边节点
                TreeNode RightNode = helper(node.right);
                RightNode.right = ori_r;
                node = node.right;
            }

        }
        
    }
    public TreeNode helper(TreeNode root){ //找最右端节点
        if (root == null) return null;
        TreeNode node = root;
        while(node.right != null){
            node = node.right;
        }
        return node;
    }
}
```

## 从前序与中序遍历序列构造二叉树

给定两个整数数组 `preorder` 和 `inorder` ，其中 `preorder` 是二叉树的**先序遍历**， `inorder` 是同一棵树的**中序遍历**，请构造二叉树并返回其根节点。

<img src="https://raw.githubusercontent.com/Yzitong/When-Java-meets-LLM/main/images/image-20250824210938398.png" alt="image-20250824210938398" style="zoom:150%;" />

通过以上三步，可确定 三个节点 ：1.树的根节点、2.左子树根节点、3.右子树根节点。

根据分治思想，对于树的左、右子树，仍可复用以上方法划分子树的左右子树。

```java
class Solution {
    public TreeNode buildTree(int[] preorder, int[] inorder) {
        //思路：先序遍历：根 左节点 右节点   中序遍历：左节点 根 右节点
        //遍历先序遍历，根据中序遍历找要插入node的位置
        //中序遍历序列用于查找的多，所以选择用哈希表储存
        HashMap<Integer,Integer> map = new HashMap<Integer,Integer>();
        for(int i = 0;i < inorder.length; i++){
            map.put(inorder[i],i);
        }
        TreeNode root = new TreeNode(preorder[0]);
        
        //遍历前序序列，将目标的结点插到指定的位置，开始构建二叉树
        for(int i = 1;i < preorder.length; i++){
            TreeNode node = new TreeNode(preorder[i]);
            insertNode(root,node,map);
        }
        return root;
        
    }
    //将目标的结点插到指定的位置
    private void insertNode(TreeNode root,TreeNode node,HashMap<Integer,Integer> map){
        //难点！通过不断改变root，减小可能得范围，找到node的插入点，最后node与root等同跳出循环
        //每次root都为根节点，root移动去找node的插入位置
        while (root != node){
            //当此node的索引值小于根节点索引值，则在其左孩子区域
            if (map.get(node.val) < map.get(root.val)) {
                if (root.left == null) root.left = node;
                root = root.left;
            }else{//否则在右孩子区域
                if (root.right == null) root.right = node;
                root = root.right;
            }
        }
    }
}
```

## 路径总和3

给定一个二叉树的根节点 `root` ，和一个整数 `targetSum` ，求该二叉树里节点值之和等于 `targetSum` 的 **路径** 的数目。

**路径** 不需要从根节点开始，也不需要在叶子节点结束，但是路径方向必须是向下的（只能从父节点到子节点）。

解决思路：利用前缀和的思想

| 560 题.和为k的数组                                 | 本题                                           |
| -------------------------------------------------- | ---------------------------------------------- |
| 连续子数组                                         | 方向向下的路径                                 |
| 前缀                                               | 从根节点开始的路径                             |
| 做法：枚举子数组**右端点**，统计有多少个**左端点** | 做法：枚举路径的**终点**，统计有多少个**起点** |

```java
class Solution {
    int ans;
    public int pathSum(TreeNode root, int targetSum) {
        //思路：前缀和+哈希表，与560.和为k的数组思路一致
        //map中存储的是：（前缀和=sum，和为sum的数量）
        Map<Long,Integer> map = new HashMap<Long,Integer>();//用long类型表示int的前缀和
        map.put(0L,1);
        dfs(root,0L,targetSum,map);

        return ans;
        
    }
    //深度优先搜索，等价于560题枚举终点的思想
    public void dfs(TreeNode node,Long sum,int targetSum,Map<Long,Integer> map){
        if (node == null) return;
        sum += node.val;
        ans += map.getOrDefault(sum - targetSum,0);
        map.put(sum,map.getOrDefault(sum,0) + 1);
        dfs(node.left,sum,targetSum,map);
        dfs(node.right,sum,targetSum,map);
        map.put(sum,map.getOrDefault(sum,0) - 1);//重点：回溯需要恢复现场
    }
}
```

## 二叉树的最近公共祖先（考）

给定一个二叉树, 找到该树中两个指定节点的最近公共祖先。

[百度百科](https://baike.baidu.com/item/最近公共祖先/8918834?fr=aladdin)中最近公共祖先的定义为：“对于有根树 T 的两个节点 p、q，最近公共祖先表示为一个节点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（**一个节点也可以是它自己的祖先**）。”

```java
class Solution {
    public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {
        //思路：深度优先的迭代，从根节点的左右子树去寻找，找到p or q就返回，作为结束条件
        if(root == null) return null;
        if(root == p) return p;
        if(root == q) return q;

         // 递归遍历左子树，寻找p或q，返回找到的节点（若左子树中存在）
        TreeNode left = lowestCommonAncestor(root.left, p, q);
        // 递归遍历右子树，寻找p或q，返回找到的节点（若右子树中存在）
        TreeNode right = lowestCommonAncestor(root.right, p, q);
        
        // 左子树和右子树都没有找到p或q，说明当前路径不包含目标节点，返回null
        if (left == null && right == null) {
            return null;
        } 
        // 左子树未找到，右子树找到，说明p和q都在右子树中，返回右子树的结果
        else if (left == null) {
            return right;
        } 
        // 右子树未找到，左子树找到，说明p和q都在左子树中，返回左子树的结果
        else if (right == null) {
            return left;
        } 
        // 左右子树分别找到p和q（或q和p），说明当前节点是它们的最近公共祖先，返回当前节点
        else {
            return root;
        }
        
        
    }
}
```

## 二叉树中的最大路径和（考）

二叉树中的 **路径** 被定义为一条节点序列，序列中每对相邻节点之间都存在一条边。同一个节点在一条路径序列中 **至多出现一次** 。该路径 **至少包含一个** 节点，且不一定经过根节点。

**路径和** 是路径中各节点值的总和。

给你一个二叉树的根节点 `root` ，返回其 **最大路径和** 。

```java
class Solution {
    int ans = Integer.MIN_VALUE;
    public int maxPathSum(TreeNode root) {
        //思路：找从下往上的累和值(链)，如果小于0就返回0，大于0就返回这个值
        //深度优先搜索求最长的子链
        dfs(root);
        return ans;

        
    }
    //dfs 方法的返回值：「单链最大和」
    public int dfs(TreeNode root){
        if (root == null) return 0;
        int lVal = dfs(root.left);
        int rVal = dfs(root.right);
        //难点：ans一定是一个过程中的最大值，因为其不一定经过根节点
        //ans 的更新：「以当前节点为中心的路径和」
        ans = Math.max(ans, lVal + rVal + root.val);
        // 当前子树最大链和（注意这里和 0 取最大值了）
        return Math.max(Math.max(lVal, rVal) + root.val,0);
    }
}
```

