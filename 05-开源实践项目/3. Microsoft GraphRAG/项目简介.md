# Microsoft GraphRAG 项目简介

开源项目：https://github.com/microsoft/graphrag?tab=readme-ov-file
论文：https://arxiv.org/pdf/2404.16130

其主要分为“索引”与“查询”两个部分，主要架构如下：

![image-20250805182632206](https://raw.githubusercontent.com/Yzitong/LLM-Mastery-Journey/main/images/image-20250805182632206.png)

## Microsoft GraphRAG 的索引构建流程，核心实现的是：

利用大模型从传入的文档内容中提取出节点（实体）和边（关系），然后利用社区检测算法对整个知识图谱进行划分，划分成多个包含了相关性较高的节点和边的子图，然后利用大模型对每个子图进行总结，生成社区报告（摘要）（该社区报告（摘要）用来描述每个子图的概况）。

当进行问答检索的时候，每个社区会依次执行 query 的检索，最终将每个社区的结果进行汇总，从而生成全局性的完整答案。



## GraphRAG 整个 Indexing 过程可以通过以下简单的方式来理解：

1. 类似于 Baseline RAG，将源文档分块为较小的子文档；
2. 执行两个并行提取：实体提取用于识别人名、地名、组织名等实体，关系提取：查找不同数据块中实体之间的关系，比如朋友、同事，员工等；
3. 创建知识图谱，其中节点表示实体，边表示它们之间的关系，比如张三是李四的朋友，张三是王五的同事；
4. 通过识别密切相关的实体来构建社区；
5. 生成不同社区级别的分层摘要；
6. 使用 reduce - map 方法通过逐步组合块来创建摘要，直到实现整体概览；



## 建立索引（Index）的过程：

第一步：将输入文件分割成文本块

1. 对于输入的文件（txt、csv、json）进行过滤，正则匹配；
2. create_base_text_units：指定分割的大小与策略，按照一定的规则分割成合适的text unit
3. create_final_documents：将“源数据 - 分块数据“进行聚合

第二步：抽取图关系

1. extract_graph：让大模型进行图元素抽取以及生成对应的摘要，即对于每个文本块识别出实体（依据提示词，可自定义实体的类型）与关系，并对于这样提取实体与关系的原因进行解释。
2. finalize_graph：将全部的”实体“与”关系“进行聚合，将执行图节 点和关系的聚合，并生成图的向量表示。

第三步：图信息增强

1. 进行社区检测，将识别出来的实体和关系分组成相 关关联的子集。利用分层的莱顿算法（Hierarchical Leiden Algorithm）将图中的节点分成多个层次的社区。Indexing 过程中 并不是在创建完第一层社区后就停止了，而是是分层的。也就是说，当创建第一层社区（即基础社区） 后，会将这些社区视为节点，进一步构建更高层级的社区，类似于一级目录、二级目录、三级目录等。
2. 之前处理的实体、关系等关联 起来，形成最终的文本单元。形成一个完整的知识图谱表示，这样，每个文本单元不仅包含原始文本，还包含了与 之相关的所有结构化信息（实体、关系）的引用，可以用于进一步 Embedding 和 后续的 Query 操作。

第四步：生成社区报告

1. 对每个社区中的节点、关系和摘要的定义进行总结。这样做的目的是为了方便查询，生成报告的策略也是借助提示工程 + 大模型实现。
2. 在完成所有的索引构建流 程且得到索引文件后，一次性的将实体、关系、社区报告等关键信息的 Embedding 向量表示生成，并在本地生成 Lancedb （轻量型数据库，作用是**向量检索引擎**）存储，用于接下来的 Query 流程。

//注：可以接入Neo4j图数据库将大模型构建的知识图谱进行可视化，来查看构建的好坏。



## 建立查询（Query）的过程：

![image-20250806181921442](https://raw.githubusercontent.com/Yzitong/LLM-Mastery-Journey/main/images/image-20250806181921442.png)

### 核心的具体步骤包括： 

1. 接收用户的查询请求。
2.  根据查询所需的详细程度，选择合适的社区级别进行分析。因此最核心的 Local Search 和 Global Search 的实现，就是源于不同的粒度级别而构建出来用于处理不同类型问题的 Pipeline , 其中：
   - Local Search 是基于实体的检索
   - Global Search 则是基于社区的检索。
3. 在选定的社区级别进行信息检索。
4. 依据社区摘要生成初步的响应。
5. 将多个相关社区的初步响应进行整合，形成一个全面的最终答案。